
import java_cup.runtime.*;
import java.util.ArrayList;
import AST.*;
import AST.block.* ;
import AST.declaration.* ;
import AST.exp.* ;
import AST.exp.binaryExp.* ;
import AST.exp.binaryExp.arithmatic.* ;
import AST.exp.binaryExp.conditional.* ;
import AST.exp.consts.* ;
import AST.exp.unaryExpression.* ;
import AST.exp.var.* ;
import AST.mehtodCall.* ;
import AST.statement.* ;
import AST.statement.loop.* ;
import AST.SymbolTable.* ;
import AST.SymbolTable.dscp.* ;



parser code {:
	boolean DEBUGS = true;

    /* Change the method report_error so it will display the line and
       column of where the error occurred in the input as well as the
       reason for the error which is passed into the method in the
       String 'message'. */
    public void report_error(String message, Object info) {

        /* Create a StringBuilder called 'm' with the string 'Error' in it. */
        StringBuilder m = new StringBuilder("Error");


        System.err.println(m);
    }

    /* Change the method report_fatal_error so when it reports a fatal
       error it will display the line and column number of where the
       fatal error occurred in the input as well as the reason for the
       fatal error which is passed into the method in the object
       'message' and then exit.*/
    public void report_fatal_error(String message, Object info) {
        report_error(message, info);
        System.exit(1);
    }
:};



terminal ID ; 
terminal SEMI ; 
terminal EXTERN ; 
terminal OPENBRAK ; 
terminal CLOSEDBRAK ; 
terminal INT ; 
terminal BOOL ; 
terminal FLOAT ; 
terminal LONG ; 
terminal CHAR ; 
terminal DOUBLE ; 
terminal STRING ; 
terminal VOID ; 
terminal AUTO ; 
terminal RECORD ; 
terminal BEGIN ; 
terminal END ; 
terminal CONST ; 
terminal COMMA ; 
terminal EQUAL ; 
terminal BEINGQ ; 
terminal ENDQ ; 
terminal RETURN ; 
terminal BREAK ; 
terminal CONTINUE ; 
terminal SIZEOF ; 
terminal IF ; 
terminal ELSE ; 
terminal SWITCH ; 
terminal OPENPRANTHES ; 
terminal CLOSEDPRANTHES ; 
terminal OPENCURLBRAK ; 
terminal CLOSEDCURLBRAK ; 
terminal OF ; 
terminal CASE ; 
terminal INT_CONST ; 
terminal DOUBLEDOT ; 
terminal FOR ; 
terminal REPEAT ; 
terminal UNITL ; 
terminal FOREACH ; 
terminal IN ; 
terminal MINUS ; 
terminal PLUS ; 
terminal EXCLEM ; 
terminal MM ; 
terminal PP ; 
terminal TILDA ; 
terminal MULT ; 
terminal DIVIDE ; 
terminal MOD ; 
terminal OR ; 
terminal AND ; 
terminal CAROT ; 
terminal EQEQUAL ; 
terminal NOTEQUAL ; 
terminal BIGEQUAL ; 
terminal SMALLEQUAL ; 
terminal SMALLER ; 
terminal BIGGER ; 
terminal ANDC ; 
terminal ORC ; 
terminal NOTC ; 
terminal REAL_CONST ; 
terminal CHAR_CONST ; 
terminal BOOL_CONST ; 
terminal STRING_CONST ; 
terminal LONG_CONST ; 
terminal DEFAULT ; 
terminal UMINUS;



terminal FALSE;
terminal GOTO;
terminal INPUT;
terminal FUNCTION ;
terminal OUTPUT ;
terminal STATIC ;
terminal TRUE ;
terminal PLUSEQUAL;
terminal MINUSEQUAL;
terminal MULTEQUAL;
terminal DIVIDEEQUAL;




nonterminal program ; 
nonterminal var_dcl ; 
nonterminal func_extern ; 
nonterminal struct_dec ; 
nonterminal func_dcl ; 
nonterminal extern_dcl ; 
nonterminal type ; 
nonterminal arguments ; 
nonterminal block ; 
nonterminal var_dcl_cnt ; 
nonterminal variable ; 
nonterminal expr ; 
nonterminal statement ; 
nonterminal assignment ; 
nonterminal method_call ; 
nonterminal cond_stmt ; 
nonterminal loop_stmt ; 
nonterminal parameters ; 
nonterminal binary_op ; 
nonterminal const_val ; 
nonterminal arithmatic ; 
nonterminal conditional ; 
nonterminal exp6 ; 
nonterminal exp10 ; 
nonterminal exp13 ; 
nonterminal exp15 ; 
nonterminal exp20 ; 
nonterminal exp23 ; 
nonterminal variablePayande;





/* Precedences */
precedence right EQUAL;
precedence left OR;
precedence left CAROT;
precedence left AND;
precedence left EQEQUAL, NOTEQUAL;
precedence left ANDC, ORC;
precedence left SMALLEQUAL,SMALLER, BIGEQUAL, BIGGER;
precedence left PLUS, MINUS;
precedence left MULT, DIVIDE, MOD;
precedence right EXCLEM;
precedence left  OPENBRAK, CLOSEDBRAK, OPENPRANTHES, CLOSEDPRANTHES;
precedence right PP, MM, NOTC;
precedence left UMINUS;








/* first */
program 	::=		var_dcl program 	{: if( DEBUGS ){ System.out.println("program found"); } :}
			|		func_extern	program		{: if( DEBUGS ){ System.out.println("program found"); } :}
			|		struct_dec	program		{: if( DEBUGS ){ System.out.println("program found"); } :}
			|						
			; 



/* second */

func_extern 	::=		func_dcl 	{: if( DEBUGS ){ System.out.println("func extern found"); } :}
				|		extern_dcl 	{: if( DEBUGS ){ System.out.println("func extern found"); } :}
				;


/* third */

func_dcl		::=		type ID OPENPRANTHES arguments CLOSEDPRANTHES SEMI 	{: if( DEBUGS ){ System.out.println("func dcl found"); } :}
				|		type ID OPENPRANTHES arguments CLOSEDPRANTHES block {: if( DEBUGS ){ System.out.println("func dcl found"); } :}
				|		type ID OPENPRANTHES CLOSEDPRANTHES SEMI 	{: if( DEBUGS ){ System.out.println("func dcl found"); } :}
				|		type ID OPENPRANTHES CLOSEDPRANTHES block 	{: if( DEBUGS ){ System.out.println("func dcl found"); } :}
				;

/* forth */

extern_dcl		::=		EXTERN type ID SEMI	{: if( DEBUGS ){ System.out.println("extern dcl found"); } :}
				;


/* fifth */
arguments 		::=		type ID exp6 COMMA arguments	{: if( DEBUGS ){ System.out.println("arguments found"); } :}
				|		type ID exp6		{: if( DEBUGS ){ System.out.println("arguments found"); } :}
				;



exp6 			::=		OPENBRAK CLOSEDBRAK exp6	{: if( DEBUGS ){ System.out.println("exp6 found"); } :}
				|	{: if( DEBUGS ){ System.out.println("exp6 found"); } :}
				;

/* sixth */
type	::=	INT 		{: if( DEBUGS ){ System.out.println("type found"); } :}
		|	BOOL 		{: if( DEBUGS ){ System.out.println("type found"); } :}
		|	FLOAT		{: if( DEBUGS ){ System.out.println("type found"); } :}
		|	LONG 		{: if( DEBUGS ){ System.out.println("type found"); } :}
		|	CHAR 		{: if( DEBUGS ){ System.out.println("type found"); } :}
		|	DOUBLE 		{: if( DEBUGS ){ System.out.println("type found"); } :}
		|	ID			{: if( DEBUGS ){ System.out.println("type found"); } :}
		|	STRING 		{: if( DEBUGS ){ System.out.println("type found"); } :}
		|	VOID		{: if( DEBUGS ){ System.out.println("type found"); } :}
		|	AUTO 		{: if( DEBUGS ){ System.out.println("type found"); } :}
		;


/* seventh */
struct_dec	::=	RECORD ID BEGIN var_dcl exp10 END RECORD SEMI  {: if( DEBUGS ){ System.out.println("struct dec found"); } :}
			;
exp10		::=	var_dcl exp10		{: if( DEBUGS ){ System.out.println("exp10 found"); } :}
			|				{: if( DEBUGS ){ System.out.println("exp10 found"); } :}
			;

/* eightth */
var_dcl 	::=	CONST type var_dcl_cnt exp13 SEMI	{: if( DEBUGS ){ System.out.println("var_dcl found"); } :}
			|	type var_dcl_cnt exp13 	SEMI		{: if( DEBUGS ){ System.out.println("var_dcl found"); } :}
			;
			
exp13		::=	COMMA var_dcl_cnt exp13		 {: if( DEBUGS ){ System.out.println("exp13 found"); } :}
			|				{: if( DEBUGS ){ System.out.println("exp13 found"); } :}
			;

/* nineth */
var_dcl_cnt		::=		variablePayande EQUAL expr	{: if( DEBUGS ){ System.out.println("var dcl cnt found"); } :}
				|		variablePayande				{: if( DEBUGS ){ System.out.println("var dcl cnt found"); } :}
				;
variablePayande ::=		ID exp23		{: if( DEBUGS ){ System.out.println("var payande found"); } :}
				;

/* tenth */
block		::=		BEGIN exp15 END	{: if( DEBUGS ){ System.out.println("block found"); } :}
			;
exp15		::=		var_dcl exp15		{: if( DEBUGS ){ System.out.println("exp15 found var"); } :}
			|		statement exp15		{: if( DEBUGS ){ System.out.println("exp15 found state"); } :}
			|  							{: if( DEBUGS ){ System.out.println("exp15 found empty"); } :}
			;

/* eleventh */
statement		::=		expr SEMI			{: if( DEBUGS ){ System.out.println("statement found"); } :}
				|		cond_stmt			{: if( DEBUGS ){ System.out.println("statement found"); } :}
				|		loop_stmt			{: if( DEBUGS ){ System.out.println("statement found"); } :}
				|		RETURN expr SEMI	{: if( DEBUGS ){ System.out.println("statement found"); } :}
				|		RETURN SEMI			{: if( DEBUGS ){ System.out.println("statement found"); } :}
				|		BREAK SEMI			{: if( DEBUGS ){ System.out.println("statement found"); } :}
				|		CONTINUE SEMI		{: if( DEBUGS ){ System.out.println("statement found"); } :}
				|		SIZEOF OPENPRANTHES type CLOSEDPRANTHES		{: if( DEBUGS ){ System.out.println("statement found"); } :}
				;

/* twelveth */
assignment		::=		variablePayande EQUAL expr		{: if( DEBUGS ){ System.out.println("assignment found"); } :}
				;

/* thirteenth */
method_call		::=		ID OPENPRANTHES parameters CLOSEDPRANTHES		{: if( DEBUGS ){ System.out.println("method found"); } :}
				|		ID OPENPRANTHES  CLOSEDPRANTHES		{: if( DEBUGS ){ System.out.println("method found"); } :}
				;

/* fourteenth */
parameters		::=		expr	{: if( DEBUGS ){ System.out.println("parameters found"); } :}
				|		expr COMMA parameters	{: if( DEBUGS ){ System.out.println("parameters found"); } :}
				;


/* fifteenth */
cond_stmt		::=		IF OPENPRANTHES expr CLOSEDPRANTHES block ELSE block	{: if( DEBUGS ){ System.out.println("cond_stmt found"); } :}
				|		IF OPENPRANTHES expr CLOSEDPRANTHES block 				{: if( DEBUGS ){ System.out.println("cond_stmt found"); } :}
				|		SWITCH OPENPRANTHES ID 	CLOSEDPRANTHES OF DOUBLEDOT OPENCURLBRAK exp20  DEFAULT DOUBLEDOT block CLOSEDCURLBRAK	{: if( DEBUGS ){ System.out.println("cond_stmt found"); } :}
				;
exp20			::=		CASE INT_CONST DOUBLEDOT block exp20	{: if( DEBUGS ){ System.out.println("exp20 found"); } :}
				|			{: if( DEBUGS ){ System.out.println("exp20 found"); } :}
				;



/* sixteenth */
loop_stmt 		::=		FOR OPENPRANTHES var_dcl SEMI expr SEMI assignment CLOSEDPRANTHES block		{: if( DEBUGS ){ System.out.println("loop_stmt found"); } :}
				|		FOR OPENPRANTHES var_dcl SEMI expr SEMI expr CLOSEDPRANTHES block			{: if( DEBUGS ){ System.out.println("loop_stmt found"); } :}
				|		FOR OPENPRANTHES var_dcl SEMI expr SEMI CLOSEDPRANTHES block				{: if( DEBUGS ){ System.out.println("loop_stmt found"); } :}
				|		FOR OPENPRANTHES SEMI expr SEMI assignment CLOSEDPRANTHES block				{: if( DEBUGS ){ System.out.println("loop_stmt found"); } :}
				|		FOR OPENPRANTHES SEMI expr SEMI expr CLOSEDPRANTHES block					{: if( DEBUGS ){ System.out.println("loop_stmt found"); } :}
				|		FOR OPENPRANTHES SEMI expr SEMI CLOSEDPRANTHES block						{: if( DEBUGS ){ System.out.println("loop_stmt found"); } :}
				|		REPEAT block UNITL OPENPRANTHES expr CLOSEDPRANTHES SEMI					{: if( DEBUGS ){ System.out.println("loop_stmt found"); } :}
				|		FOREACH OPENPRANTHES ID IN ID CLOSEDPRANTHES block							{: if( DEBUGS ){ System.out.println("loop_stmt found"); } :}
				;








/* eighteenth */
expr		::=		expr:e1  binary_op:e2  expr:e3			{: if( DEBUGS ){ System.out.println("expr found"); }RESULT = ((BinaryExp)e2).SetBinaryExp((BinaryExp)e1,(BinaryExp)e3);  :}
			|		OPENPRANTHES expr CLOSEDPRANTHES	{: if( DEBUGS ){ System.out.println("expr found"); } :}
			|		method_call	{: if( DEBUGS ){ System.out.println("expr found"); } :}
			|		variable		{: if( DEBUGS ){ System.out.println("expr found"); } :}
			|		const_val		{: if( DEBUGS ){ System.out.println("expr found"); } :}
			|		MINUS expr {: if( DEBUGS ){ System.out.println("expr found"); } :}	%prec  UMINUS
			|		EXCLEM expr	{: if( DEBUGS ){ System.out.println("expr found"); } :}
			|		assignment  	{::}
			;



/* tweenth */
variable		::=		ID exp23	{: if( DEBUGS ){ System.out.println("variable found"); } :}
				|		TILDA variable	{: if( DEBUGS ){ System.out.println("variable found"); } :}
				|		MM variable	{: if( DEBUGS ){ System.out.println("variable found"); } :}
				|		PP variable	{: if( DEBUGS ){ System.out.println("variable found"); } :}
				|		variable MM	{: if( DEBUGS ){ System.out.println("variable found"); } :}
				|		variable PP	{: if( DEBUGS ){ System.out.println("variable found"); } :}
				;

exp23			::=		OPENBRAK expr CLOSEDBRAK exp23	{: if( DEBUGS ){ System.out.println("exp32 found"); } :}
				|	{: if( DEBUGS ){ System.out.println("exp23 found"); } :}
				;



/* tweny first */
binary_op		::=		arithmatic:e	{: if( DEBUGS ){ System.out.println("binary op found");RESULT = (BinaryExp)e; } :}
				|		conditional:e	{: if( DEBUGS ){ System.out.println("binary op found"); }RESULT = (BinaryExp)e; :}
				;

/* twenty second */
arithmatic		::=		PLUS	{: if( DEBUGS ){ System.out.println("arithmatic found"); } RESULT = new AST.exp.binaryExp.arithmatic.Plus();:}
				|		MINUS	{: if( DEBUGS ){ System.out.println("arithmatic found"); } RESULT = new AST.exp.binaryExp.arithmatic.Minus();:}
				|		MULT	{: if( DEBUGS ){ System.out.println("arithmatic found"); } RESULT = new AST.exp.binaryExp.arithmatic.Mult();:}
				|		DIVIDE	{: if( DEBUGS ){ System.out.println("arithmatic found"); } RESULT = new AST.exp.binaryExp.arithmatic.Divide();:}
				|		MOD		{: if( DEBUGS ){ System.out.println("arithmatic found"); } RESULT = new AST.exp.binaryExp.arithmatic.Mod();:}
				|		AND		{: if( DEBUGS ){ System.out.println("arithmatic found"); } RESULT = new AST.exp.binaryExp.arithmatic.And();:}
				|		OR		{: if( DEBUGS ){ System.out.println("arithmatic found"); } RESULT = new AST.exp.binaryExp.arithmatic.Or();:}
				|		CAROT	{: if( DEBUGS ){ System.out.println("arithmatic found"); } RESULT = new AST.exp.binaryExp.arithmatic.Carot();:}
				;


/* twenty third */
conditional		::=		EQEQUAL		{: if( DEBUGS ){ System.out.println("conditional found"); } RESULT = new EqEqual(); :}
				|		NOTEQUAL	{: if( DEBUGS ){ System.out.println("conditional found"); } RESULT = new NotEqual();:}
				|		BIGEQUAL	{: if( DEBUGS ){ System.out.println("conditional found"); } RESULT = new GreaterEqual();:}
				|		SMALLEQUAL	{: if( DEBUGS ){ System.out.println("conditional found"); } RESULT = new SmallerEqual();:}
				|		SMALLER		{: if( DEBUGS ){ System.out.println("conditional found"); } RESULT = new Smaller();:}
				|		BIGGER		{: if( DEBUGS ){ System.out.println("conditional found"); } RESULT = new Greater(); :}
				|		ANDC		{: if( DEBUGS ){ System.out.println("conditional found"); } RESULT = new AST.exp.binaryExp.conditional.And();:}
				|		ORC			{: if( DEBUGS ){ System.out.println("conditional found"); } RESULT = new AST.exp.binaryExp.conditional.Or();:}
				|		NOTC		{: if( DEBUGS ){ System.out.println("conditional found"); } RESULT = new AST.exp.binaryExp.conditional.Not();:}
				;


/* twenty fourth */
const_val		::=		INT_CONST:e		{: if( DEBUGS ){ System.out.println("const val found by INT_CONST"); } RESULT = new IntConstExp(HelperFunctions.parseInt((String)e)) ; :}
				|		REAL_CONST:e		{: if( DEBUGS ){ System.out.println("const val found by REAL_CONST"); } RESULT = new RealConstExp(Double.parseDouble((String)e)); :}
				|		CHAR_CONST:e		{: if( DEBUGS ){ System.out.println("const val found by CHAR_CONST"); } RESULT = new CharConstExp(((String)e).charAt(0)) ; :}
				|		BOOL_CONST:e		{: if( DEBUGS ){ System.out.println("const val found by BOOL_CONST"); } RESULT = new BooleanConstExp(((String)e).equals("true" )? true : false ) ; :}
				|		STRING_CONST:e	{: if( DEBUGS ){ System.out.println("const val found by STRING_CONST"); } RESULT = new StringConstExp((String)e); :}
				|		LONG_CONST:e		{: if( DEBUGS ){ System.out.println("const val found by LONG_CONST"); }   :}
				;












